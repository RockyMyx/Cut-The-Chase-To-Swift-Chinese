如果不想让一个方法、属性或者索引被重写，可以在声明时使用@final标识
如@final class, @final var, @final func, @final class func, @final subscript

声明任一种构造器时，可以使用requierd来标记构造器，要求所有子类重写构造器

你可以使用required关键字，将便利构造器和指定构造器标记为每个子类的构造器都必须拥有的。因为指定构造器 不被子类继承，它们必须被立即执行。当子类直接执行所有超类的指定构造器(或使用便利构造器重写指定构造器)时， 必需的便利构造器可以被隐式的执行，亦可以被继承。你不需要为这些重写的构造器标注 overrride关键字。


组合运算符重载

赋值符号需要使用`@assignment`标记，还需要把运算符的左参数设置成`inout`，因为这个参数会在运算符函数内直接修改它的值。

	@assignment func += (inout left: Vector2D, right: Vector2D) {
	    left = left + right
	}

	var original = Vector2D(x: 1.0, y: 2.0)
	let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
	original += vectorToAdd
	// original 现在为 (4.0, 6.0)

可以将 `@assignment` 属性和 `@prefix` 或 `@postfix` 属性起来组合，实现一个`Vector2D`的前置运算符。

	@prefix @assignment func ++ (inout vector: Vector2D) -> Vector2D {
	    vector += Vector2D(x: 1.0, y: 1.0)
	    return vector
	}

	@prefix @assignment func +++ (inout vector: Vector2D) -> Vector2D {
	    vector += vector
	    return vector
	}
	
	var toIncrement = Vector2D(x: 3.0, y: 4.0)
	let afterIncrement = ++toIncrement
	// toIncrement 现在是 (4.0, 5.0)
	// afterIncrement 现在也是 (4.0, 5.0)

	var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
	let afterDoubling = +++toBeDoubled
	// toBeDoubled 现在是 (2.0, 8.0)
	// afterDoubling 现在也是 (2.0, 8.0)
