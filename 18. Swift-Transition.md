MS的C#，Sun的java，Mozilla的JavaScript，在读完Swift的官方文档后我的最大感受就是Swift在设计时融合了这三门语言的众多优秀的特性，下面我将总结一些例子以供参考。

**1、变量定义**

Swift中的变量定义和JavaScript可以说是一个模子刻出来的：

创建Variable

    var i = 0 //定义变量，初始值为0

创建Array

	var list = ["a", "b", "c"];

创建Dict，相当于创建json对象

	let numDict = [
		"a" : [1,2,3],
		"b" : [4,5,6],
		"c" : [7,8,9]
	]

**2、循环**

类似于JavaScript，使用for...in遍历数组

	for i in list {
		
	}

**3、延迟属性**

C#中使用Lazy<T>配合Lambda表达式实现

	public class Hero
	{
	    public string Name { get; set; }
	    
	    private Lazy<SpecialSkill> skill;
	    public SpecialSkill Skill
	    {
	        get { return skill.Value; }
	    }
	
	    public Hero(string name)
	    {
	        Name = name;
	        skill = new Lazy<SpecialSkill>(() => new SpecialSkill(name));
	    }
	}

	public class SpecialSkill
	{
	    public string SkillName { get; set; }
	    public SpecialSkill(string name)
	    {
	        SkillName = name + " Blazing";
	        Console.WriteLine(SkillName + ",... this's what makes a legend!");
	    }
	} 

	class Program
	{
	    static void Main(string[] args)
	    {
	        Hero hero = new Hero("xxx");            
	        Console.WriteLine("Hero's special skill: " + hero.Skill.SkillName);
	        Console.Read();
	    }
	}

Swift中使用@lazy标注

	class Hero {
		var name: String { get; set;}
		
		init(name: String) {
			self.name = name;
			@lazy var skill: SpecialSkill = SpecialSkill(name);
	    }
	}

	class SpecialSkill {
		var SkillName: String { get; set; }
		init(name: String) {
			SkillName = name + " Blazing";
			println(SkillName + ",... this's what makes a legend!");
		}
	}

**4、嵌套函数**

JavaScript：

	function returnFifteen() {
	    var y = 10;
	    function add() {
	        y += 5;
	    }
	    add();
	    return y;
	}

Swift：

	func returnFifteen() -> Int(){
		var y = 10;
		func add(){
			y += 5;
		}
		add();
		return y;
	}

**5、函数参数**

函数可以使用另一个函数作为参数

JavaScript：

	function hasAnyMatches(list, condition) {
		for(var item in list) {
			if (condition(item)) {
				return true
			}
		}

		return false
	}

	function lessThanTen(number) {
		return number < 10;
	}

	hasAnyMatches([1,5,8,10,34,11,62,4], lessThanTen);

Swift：

	func hasAnyMatches(list: Int[], condition: Int->Bool) -> Bool {
		for item in list {
			if (condition(item)) {
				return true
			}
		}

		return false
	}

	func lessThanTen(number: Int) -> Bool {
		return number < 10;
	}
	
	hasAnyMatches([1,5,8,10,34,11,62,4], lessThanTen);

**6、函数返回值**

Swift中可以定义一个变量或者常量表示拥有特定参数类型和返回值的函数, 类似于C#中的委托

	func addTwoInts(firstInt: Int, secondInt: Int) -> Int {
		return firstInt + secondInt
	}

	var mathFunction: (Int, Int) -> Int = addTwoInts

	//在调用时可以使用：
	mathFunction(2,3)

**7、柯里化函数**

JavaScript：

	function addTwoNumbers(x) {
	    return function(y) {
	        return x + y
	    }
	}

Swift：

	func addTwoNumbers(a: Int) -> (Int -> Int) {
	    func addTheSecondNumber(b: Int) -> Int {
	        return a + b
	    }

	    return addTheSecondNumber
	}

**8、函数中可变参数**

C#有params， Java有...， JavaScripts有arguments

在Swift中的语法与Java一样，使用`...`表示可变参数，一个函数最多只有一个可变参数，并且必须出现在函数的最后

	func sumOf(numbers: Int...) -> Int {
		var sum = 0;
		for num in numbers {
			sum += num
		}
		return sum;
	}

**9、函数中默认值参数**

Java中不支持

JavaScript中可以在方法内部设置参数默认值

	function join(s1, s2, joiner) {
		joiner = joiner || ",";
		return s1 + joiner + s2
	}

C#中支持为函数参数提供默认值，Swift的语法与C#一样

	func join(s1: String,  s2: String,  joiner: String = ", ") -> String {
		return s1 + joiner + s2
	}

	join("hello",  "world")

**10、立即执行的闭包**

JavaScript中函数后紧接一对小括号表示立即执行：

	(function executeNow() {
	    console.log("1");
	})();

Swift闭包结尾的大括号后面接了一对空的小括号，则此闭包会立即执行。如果你忽略了这对括号，相当于是将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。

	class SomeClass {
	    let someProperty: SomeType = {
	        return someValue
	    }()
	}

**11、类型扩展**

C#中的扩展在定义时有严格的限制，必须在public的静态类中定义public的静态方法，并且第一个参数是 `this 要扩展的类型`，如：

	public static class StringExtension
	{
		public static int GetLength (this string s) 
		{
			return s.length;
		}
	}

Swift中同样有扩展，使用extension标识

	extension String {
		func GetLength (s: String) -> Int {
			return s.countElements();
		}
	}

**12、部分类**

C#中提供了部分类用于在多处定义同一个类，使用关键字partial，如：

	public partial class MyClass
	{
		public int i = 0;
	}

	public partial class MyClass
	{
		public int j = 0;
	}

Swift中可以使用扩展达到同样的效果：

	extension class MyClass {
		var i = 0;
	}

	extension class MyClass {
		var j = 0;
	}

**13、类的索引（下标）访问**

C#中使用下标访问相关的类成员

	public class TimesTable
	{
		public int multiplier;

		public TimesTable(int multiplier) 
		{
			this.multiplier = multiplier;
		}

		public int this[int index]
		{
			return multiplier * index;
		}
	}

	TimesTable threeTimesTable = new TimesTable(3);
	Console.WriteLine(string.Format(""six times three is {0}", threeTimesTable[6]);

Swift中通过定义subscript函数可以实现同样的效果

	class TimesTable {
	    let multiplier: Int
	    subscript(index: Int) -> Int {
	        return multiplier * index
	    }
	}

	let threeTimesTable = TimesTable(multiplier: 3)
	println("six times three is \(threeTimesTable[6])")

**14、类型别名**

C#中过长的类型可以使用using简化，如：

	using PluService = System.Data.Entity.Design.PluralizationServices;

Swift中使用typealias实现对应效果

**15、动态类型**

动态类型即在编译时不检验实例的类型，而在运行时动态判断，调用相应的属性、方法等。

C#中使用dynamic

	public class DynamicSample
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
    }

	dynamic dynamicSample = new DynamicSample();
	dynamicSample2.Add(1, 2);

Swift中使用dynamicType

	class SomeBaseClass {
	    class func printClassName（） {
	        println（"SomeBaseClass"）
	    }
	}
	class SomeSubClass: SomeBaseClass {
	    override class func printClassName（） {
	        println（"SomeSubClass"）
	    }
	}

	let someInstance: SomeBaseClass = SomeSubClass（）
	// someInstance编译时类型是SomeBaseClass，运行时类型是SomeSubClass
	someInstance.dynamicType.printClassName（）
	// prints "SomeSubClass"

**16、泛型类型**

使用where指明泛型类的约束条件，语法与C#类似

除了where，还可以在泛型参数后面写冒号类名或protocol名，如使用<T: Equatable>
Equatable>.

	func anyCommonElements <T, U 
		where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable,
	          T.GeneratorType.Element == U.GeneratorType.Element> 
		(lhs: T, rhs: U) -> Bool {
	    for lhsItem in lhs {
	        for rhsItem in rhs {
	            if lhsItem == rhsItem {
	                return true
	            }
	        }
	    }
	    return false
	}
	anyCommonElements([1, 2, 3], [3, 4, 5])

	---------------------------------------------------------

	func allItemsMatch<C1: Container, C2: Container
	                   where C1.ItemType == C2.ItemType, C1.ItemType: Equatable>
	    (someContainer: C1, anotherContainer: C2) -> Bool {
	
	        if someContainer.count != anotherContainer.count {
	            return false
	        }
	
	        for i in 0..someContainer.count {
	            if someContainer[i] != anotherContainer[i] {
	                return false
	            }
	        }
	
	        return true
	}

Swift 标准库中定义了一个Equatable协议，该协议要求任何遵循的类型实现等式符（==）和不等符（!=）对任何两个该类型进行比较。所有的 Swift基本类型自动支持Equatable协议。

	func findIndex<T: Equatable>(array: T[], valueToFind: T) -> Int? {
	    for (index, value) in enumerate(array) {
	        if value == valueToFind {
	            return index
	        }
	    }
	    return nil
	}

//TODO补充C#  IComparable例子

**17、手动释放资源**

C#、Java、Swift虽然都提供了自动的垃圾回收，但也提供了相关的函数手动处理一些资源的释放工作

C#：dispose， ~className()

Java：finalize()

Swift：deinit()

**18、运算符重载**

与C#类似，提供了运算符的重载功能。

Swift自定义运算符及使用

	operator infix +- { associativity left precedence 140 }
	func +- (left: Vector2D, right: Vector2D) -> Vector2D {
	    return Vector2D(x: left.x + right.x, y: left.y - right.y)
	}
	let firstVector = Vector2D(x: 1.0, y: 2.0)
	let secondVector = Vector2D(x: 3.0, y: 4.0)
	let plusMinusVector = firstVector +- secondVector
	// plusMinusVector 此时的值为 (4.0, -2.0)

**19、"委托"**

可以使用"委托"作为函数的参数

	func printMathResult(mathFunction: (Int, Int) -> Int, a: Int, b: Int) {
		println(mathFunction(a, b))
	}

	func addTwoInts(number1: Int, number2: Int) {
		return number1 + number2;
	}

	printMathResult(addTwoInts, 1, 2)

可以将"委托"赋值为任何符合参数和返回类型约束的函数

	func multiplyTwoInts(firstInt: Int, secondInt: Int) -> Int {
		return firstInt * secondInt
	}

	mathFunction = multiplyTwoInts

//TODO 补充C#例子

**20、PS：**

Swift还有PHP里的魔术常量

`__COLUMN__`：所在的列数

`__FILE__`：所在的文件名

`__FUNCTION__`：所在的function 的名字

`__LINE__`：所在的行数




