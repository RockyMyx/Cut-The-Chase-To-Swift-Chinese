1、定义类：class

Swift允许你定义嵌套类型，可以在枚举类型、类和结构体中定义支持嵌套的类型。

2、类的构造器

类可以有指定（Designated）和方便（Convenient）两种构造器。
	
	//指定构造器
	init(parameters) {
	    statements
	}

	//方便构造器
	convenience init(parameters) {
    	statements
	}

指定（Designated）构造器：
	
	必须初始化类所有的已声明的属性
	根据父类链往上调用父类的构造器来实现父类的初始化。
	如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。
	如果子类提供了所有父类指定构造器的实现，它将自动继承所有父类的方便构造器

//TODO加例子说明

方便（Convenient）构造器：
	
	必须调用同一类中定义的其它构造器，且以调用一个指定构造器结束，即横向代理。
	用于创建一个特殊用途或特定输入的实例。
	应当只在必要的时候为类提供便利构造器。

声明任一种构造器时，可以使用requierd来标记构造器，要求所有子类重写构造器。

跟函数（function）不同，构造器不能返回值。

	var xx = SomeClass.init // error

3、类的实例

有两种方法来创建已声明的类的实例：

调用类的一个构造器，参见构造器(initializers)。
如果没有声明构造器，而且类的所有属性都被赋予了初始值，调用类的默认构造器

4、类的索引（Subscript）

可以在类中定义索引，从而通过[index]语法访问相应元素

	subscipt(index: Int) -> Int {
		get {
	
		}
		//newValue可以省略不写
		set(newValue) {
	
		}
	}

索引访问也可以定义为只读的：

	struct TimesTable {
	    let multiplier: Int
	    subscript(index: Int) -> Int {
	        return multiplier * index
	    }
	}
	let threeTimesTable = TimesTable(multiplier: 3)
	println("six times three is \(threeTimesTable[6])")

索引可以使用变量或者可变参数，但是不能使用inout参数或者有默认值的参数

索引可以重载，可以定义多个参数

	struct Matrix {
	    let rows: Int,  columns: Int
	    var grid: Double[]
	    init(rows: Int, columns: Int) {
	        self. rows = rows
	        self. columns = columns
	        grid = Array(count: rows * columns,  repeatedValue: 0.0)
	    }
	    func indexIsValidForRow (row: Int, column: Int) -> Bool  {
			return row >= 0 && row < rows && column >= 0 && column < columns
		}
		subscript(row: Int, column: Int) -> Double {
			get {
				assert(indexIsValidForRow(row, column: column), "Index out of range")
				return grid[(row * columns) + column]
			}
			set {
				assert(indexIsValidForRow(row , column: column), "Index out of range")
				grid[(row * columns) + column] = newValue
			}
		}
	}
	Matrix matrix = Matrix(2, 2)
	//grid = [0.0, 0.0, 0.0 ,0.0]
	matrix[0, 1] = 1.5
	matrix[1, 0] = 3.2
	/*matrix = [ 0.0, 1.5
	             3.2, 0.0 ]*/


5、类的继承

跟 Objective-C 中的子类不同，Swift 中的子类不会默认继承父类的构造器（父类的属性和方法可以被继承）。Swift的这种机制可以防止一个父类的简单构造器被一个专门的子类继承，并被错误的用来创建子类的实例。

但是超类声明的指定(Designated)构造器却不能。这意味着，如果当前类重写了超类的所有指定构造器，它就继承了超类的方便（Convenient）构造器。

	class Shape {
		var numberOfSides = 0
		func simpleDescription() -> String {
			return "Shape simpleDescription"
		}
	
		var name: String
		//指定（Designated）构造器
		init(name: String) {
			self.name = name;
		}
	}

	//声明类实例
	var shape = SomeClass();
	//调用实例方法
	shape.simpleDescription();

6、类的扩展（extension）

扩展就是向一个已有的类、结构体或枚举类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。

扩展和 Objective-C 中的分类（categories）类似。（不过与Objective-C不同的是，Swift 的扩展没有名字。）

扩展可以：

	添加计算型属性和计算静态属性；
	定义实例方法和类型方法；
	提供新的构造器；
	定义下标；
	定义和使用新的嵌套类型；
	使一个已有类型符合某个协议
	向类中添加新的便利构造器

扩展不可以：
	
	添加存储属性，
	向已有属性添加属性监视器
	向类中添加新的指定构造器或析构函数。指定构造器和析构函数必须总是由原始的类实现来提供。


扩展可以向已有类型添加新的实例方法和类型方法。下面的例子向Int类型添加扩展实例方法：

	extension Int {
	    func repetitions(task: () -> ()) {
	        for i in 0..self {
	            task()
	        }
	    }
	}

	3.repetitions({println("Hello!")})
	//等价于
	3.repetitions{println("Hello!")}
	//结果
	// Hello!
	// Hello!
	// Hello!


对于类和结构体进行扩展时，要完全按照类或结构体的定义方式写：

	extension SomeType: SomeProtocol, AnotherProctocol {
	    // 协议实现写到这里
	}


如果你使用扩展向一个值类型添加一个构造器，在该值类型已经向所有的存储属性提供默认值，而且没有定义任何定制构造器（custom initializers）时，可以在值类型的扩展构造器中调用默认构造器(default initializers)和逐一成员构造器(memberwise initializers)。如果你已经把构造器写成值类型原始实现的一部分，上述规则不再适用。

结构体的扩展：

	struct Size {
	    var width = 0.0, height = 0.0
	}
	struct Point {
	    var x = 0.0, y = 0.0
	}
	struct Rect {
	    var origin = Point()
	    var size = Size()
	}
	extension Rect {
	    init(center: Point, size: Size) {
	        let originX = center.x - (size.width / 2)
	        let originY = center.y - (size.height / 2)
	        self.init(origin: Point(x: originX, y: originY), size: size)
	    }
	}
	let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))
	// centerRect的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)


7、类型转换

用类型检查操作符(is)来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true ，否则返回 false 。

向下类型转换使用as，如果不确定是否转换成功，可以使用as?

8、任意类型

Swift为不确定类型提供了两种特殊类型别名：
	
AnyObject：可以代表任何class类型的实例。

Any：可以表示任何类型，除了方法类型（function types）。

	var things = Any[]()
	
	things.append(0)
	things.append(0.0)
	things.append(42)
	things.append(3.14159)
	things.append("hello")
	things.append((3.0, 5.0))
	things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))
	
	for thing in things {
	    switch thing {
	    case 0 as Int:
	        println("zero as an Int")
	    case 0 as Double:
	        println("zero as a Double")
	    case let someInt as Int:
	        println("an integer value of \(someInt)")
	    case let someDouble as Double where someDouble > 0:
	        println("a positive double value of \(someDouble)")
	    case is Double:
	        println("some other double value that I don't want to print")
	    case let someString as String:
	        println("a string value of \"\(someString)\"")
	    case let (x, y) as (Double, Double):
	        println("an (x, y) point at \(x), \(y)")
	    case let movie as Movie:
	        println("a movie called '\(movie.name)', dir. \(movie.director)")
	    default:
	        println("something else")
	    }
	}

9、泛型类

	func repeat<ItemType>(item: ItemType, times: Int) -> ItemType[] {
		var result = ItemType[]();
		for i in 0..times {
			result += item
		}
		return result;
	}

使用where指明泛型类的约束条件

除了where，还可以在泛型参数后面写冒号类名或protocol名，如使用<T: Equatable>
Equatable>.

	func anyCommonElements <T, U 
		where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable,
	          T.GeneratorType.Element == U.GeneratorType.Element> 
		(lhs: T, rhs: U) -> Bool {
	    for lhsItem in lhs {
	        for rhsItem in rhs {
	            if lhsItem == rhsItem {
	                return true
	            }
	        }
	    }
	    return false
	}
	anyCommonElements([1, 2, 3], [3, 4, 5])