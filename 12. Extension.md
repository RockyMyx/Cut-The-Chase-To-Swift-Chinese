
通过扩展为已存在的类型遵循协议时，该类型的所有实例也会随之添加协议中的方法
	
	protocol TextRepresentable {
	    func asText() -> String
	}
	extension Dice: TextRepresentable {
	    func asText() -> String {
	        return "A \(sides)-sided dice"
	    }
	}

	extension Int {
	    subscript(digitIndex: Int) -> Int {
	        var decimalBase = 1
            for _ in 1...digitIndex {
                decimalBase *= 10
            }
	        return (self / decimalBase) % 10
	    }
	}
	746381295[0]
	// returns 5
	746381295[1]
	// returns 9

//Int值没有足够的位数，即下标越界，那么上述实现的下标会返回0，因为它会在数字左边自动补0：
746381295[9]
//returns 0


当一个类型已经实现了协议中的所有要求，却没有声明时，可以通过扩展来补充协议声明:

	struct Hamster {
	    var name: String
	    func asText() -> String {
	        return "A hamster named \(name)"
	    }
	}
	extension Hamster: TextRepresentable {}


	extension Character {
	    enum Kind {
	        case Vowel, Consonant, Other
	    }
	    var kind: Kind {
	        switch String(self).lowercaseString {
	        case "a", "e", "i", "o", "u":
	            return .Vowel
	        case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
	             "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
	            return .Consonant
	        default:
	            return .Other
	        }
	    }
	}
	func printLetterKinds(word: String) {
	    println("'\\(word)' is made up of the following kinds of letters:")
	    for character in word {
	        switch character.kind {
	        case .Vowel:
	            print("vowel ")
	        case .Consonant:
	            print("consonant ")
	        case .Other:
	            print("other ")
	        }
	    }
	    print("\n")
	}
	printLetterKinds("Hello")
	// 'Hello' is made up of the following kinds of letters:
	// consonant vowel consonant consonant vowel


deinit不能出现在扩展中

属性，方法，现存类型的构造器不能被它们类型的扩展所重写。